<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2017-05-14T13:23:54-04:00</updated><id>/</id><title type="html">Albert blog</title><subtitle></subtitle><entry><title type="html">Playing around with WebAssembly</title><link href="/cpp/2017/05/10/playing-around-with-webassembly.html" rel="alternate" type="text/html" title="Playing around with WebAssembly" /><published>2017-05-10T00:00:00-04:00</published><updated>2017-05-10T00:00:00-04:00</updated><id>/cpp/2017/05/10/playing-around-with-webassembly</id><content type="html" xml:base="/cpp/2017/05/10/playing-around-with-webassembly.html">&lt;p&gt;WebAssembly aka wasm is an efficient low-level bytecode format for compilation to the web browsers, initial aim for &lt;em&gt;wasm&lt;/em&gt; is compilation C/C++ code, but also other languages are supported such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Rust_programming_language&quot;&gt;Rust&lt;/a&gt;. Wasm allows run code faster and efficient, thanks to wasm code is &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_machine&quot;&gt;stack machine&lt;/a&gt;. Wasm can be interpreted as the game changer for the web, which compiles C++/C into byte code and it can be run with near-native performance, it’s amazing!&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/MaJCfdmr9Wg&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;There exist a popular &lt;a href=&quot;https://en.wikipedia.org/wiki/Asm.js&quot;&gt;asm.js&lt;/a&gt; which allow the almost the same as wasm except for a few important features for wasm:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Wasm compiled into &lt;strong&gt;byte-code&lt;/strong&gt;, when asm.js is modified high-perfomance js language. It’s means asm.js can be parsed &lt;a href=&quot;https://blog.mozilla.org/luke/2014/01/14/asm-js-aot-compilation-and-startup-performance/&quot;&gt;slower&lt;/a&gt; than wasm can be decoded, some sources says it’s faster than in 20x times. That allow decrease waiting time for your &lt;strong&gt;users&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Constant-time type checking, and well-formedness cheching.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://webassembly.org/docs/rationale/&quot;&gt;Rational designed&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Stack machine allow smaller binary encoding.&lt;/li&gt;
      &lt;li&gt;Dense Encoding and effecient decoding, compilation, and interpratation - thanks to stack machine.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you have a project written in &lt;code class=&quot;highlighter-rouge&quot;&gt;asm.js&lt;/code&gt;, you can easily compile it into wasm.&lt;/p&gt;
&lt;h2 id=&quot;use-cases&quot;&gt;Use cases&lt;/h2&gt;
&lt;p&gt;First of all, wasm can be run on the web platform and &lt;a href=&quot;https://github.com/WebAssembly/design/blob/master/NonWeb.md&quot;&gt;non-web&lt;/a&gt; platforms - like Node.js. In web platform, wasm has a wide range of usage, for me as AR developer to which is important every millisecond, wasm can be lifebuoy to run AR algorithms in the web.&lt;/p&gt;

&lt;h4 id=&quot;wasm-use-cases&quot;&gt;Wasm use-cases:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Working with wide range of library which wrote on C++&lt;/li&gt;
  &lt;li&gt;Image/video editing.&lt;/li&gt;
  &lt;li&gt;Audio Industry - &lt;a href=&quot;https://www.youtube.com/watch?v=boPEO2auJj4&quot;&gt;thanks to Timur Doumler&lt;/a&gt; for this great video about performance in the audio industry.&lt;/li&gt;
  &lt;li&gt;Music streaming.&lt;/li&gt;
  &lt;li&gt;Image recognition.&lt;/li&gt;
  &lt;li&gt;Video augmentation(like snapchat lenses put’s some assets on your face)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VR and AR&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Scientific simulation and visualization.&lt;/li&gt;
  &lt;li&gt;Developing tooling(IDE’s, compilers, debugger, etc.) - Microsoft currently running &lt;a href=&quot;https://www.visualstudio.com/vso/&quot;&gt;visual studion&lt;/a&gt; in the browser.&lt;/li&gt;
  &lt;li&gt;Platform simulation, virtual machines&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A full list of wasm use cases you can find &lt;a href=&quot;https://github.com/WebAssembly/design/blob/master/UseCases.md&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;demos&quot;&gt;Demo’s&lt;/h3&gt;

&lt;h4 id=&quot;wasm&quot;&gt;Wasm&lt;/h4&gt;
&lt;p&gt;OOn main wasm website, you can find Unity game &lt;a href=&quot;http://webassembly.org/demo/&quot;&gt;‘Tanks’&lt;/a&gt; which ported to wasm.
&lt;img src=&quot;http://i.imgur.com/YMpbScY.png&quot; alt=&quot;Tanks&quot; /&gt;
 Also, I found &lt;a href=&quot;https://s3.amazonaws.com/mozilla-games/ZenGarden/EpicZenGarden.html&quot;&gt;EpicZenGarder&lt;/a&gt;. I recommend to you run it on latest Firefox version. 
&lt;img src=&quot;http://i.imgur.com/rFNkWko.jpg&quot; alt=&quot;EpicZenGarden&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;asmjs&quot;&gt;Asm.js&lt;/h4&gt;
&lt;p&gt;Asm.js not poor for demos unlike wasm, it has a lot of demo’s, you can find full list &lt;a href=&quot;https://github.com/kripken/emscripten/wiki/Porting-Examples-and-Demos&quot;&gt;here&lt;/a&gt;. I really enjoy &lt;a href=&quot;www.quakejs.com&quot;&gt;Quake&lt;/a&gt; port ☺️
&lt;img src=&quot;http://i.imgur.com/qS11j2B.jpg&quot; alt=&quot;Quakejs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jamesfriend.com.au/pce-js&quot;&gt;Classic MacOS&lt;/a&gt;
&lt;img src=&quot;http://i.imgur.com/PXNix3P.png&quot; alt=&quot;MacOS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://kripken.github.io/sql.js/GUI/&quot;&gt;SQLite ported to js!&lt;/a&gt;
&lt;img src=&quot;http://i.imgur.com/53e5Xup.png&quot; alt=&quot;SQLite.js&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;instalation&quot;&gt;Instalation&lt;/h3&gt;

&lt;p&gt;For compilation from LLVM which can be generated by C++/C to wasm we will use awesome project &lt;a href=&quot;https://github.com/kripken/emscripten.git&quot;&gt;emscripten&lt;/a&gt;. If you use &lt;em&gt;Windows&lt;/em&gt; please skip this section and use this &lt;a href=&quot;https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html&quot;&gt;link&lt;/a&gt; to install.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/libs
wget https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz
tar -xzf emsdk-portable.tar.gz &amp;amp;&amp;amp; rm emsdk-portable.tar.gz
cd emsdk-portable
./emsdk update
./emsdk install latest
./emsdk activate latest

## Set system path
source ./emsdk_env.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;emscripten&quot;&gt;Emscripten&lt;/h4&gt;
&lt;p&gt;Emscripten is a compiler, which takes &lt;a href=&quot;https://en.wikipedia.org/wiki/LLVM&quot;&gt;LLVM&lt;/a&gt; code as input and generates .js code, like asm.js code. Also, it can be used to compile into web assembly format. Emscripten used inside &lt;a href=&quot;https://github.com/WebAssembly/binaryen&quot;&gt;binaryen toolchain&lt;/a&gt; to compile into .wasm format. It takes c++ llvm bitcode, compile it into .s file, uses &lt;code class=&quot;highlighter-rouge&quot;&gt;s2wasm&lt;/code&gt; command from binaryen project to generate wasm bitcode.
&lt;img src=&quot;http://i.imgur.com/zGS4DaY.png&quot; alt=&quot;Emscipten compilation diagramm&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;compile-simple-c11-code&quot;&gt;Compile simple C++{11} code&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;array&amp;gt;
#include &amp;lt;iterator&amp;gt;

int main(){
    std::array&amp;lt;int, 20&amp;gt; array;
    for(int i=0;i&amp;lt;array.size();i++){
        array[i] = i;
    }
    std::random_shuffle(array.begin(), array.end());

    std::cout&amp;lt;&amp;lt;&quot;Shuffled array&quot;&amp;lt;&amp;lt;std::endl;
    std::copy(array.begin(), array.end(),std::ostream_iterator&amp;lt;int&amp;gt;(std::cout,&quot; &quot;));
    std::cout&amp;lt;&amp;lt;std::endl;
	
	//Sorting
    std::sort(array.begin(),array.end());

    std::cout&amp;lt;&amp;lt;&quot;Sorted array&quot;&amp;lt;&amp;lt;std::endl;
    std::copy(array.begin(), array.end(),std::ostream_iterator&amp;lt;int&amp;gt;(std::cout,&quot; &quot;));
    std::cout&amp;lt;&amp;lt;std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;simple.cpp&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here we create a simple code, which fills array of length 20, shuffle it, and sort it. As you can see we use c++11 std::array, and standard library algorithms.&lt;/p&gt;

&lt;h5 id=&quot;compile-c-into-wasm&quot;&gt;Compile C++ into wasm&lt;/h5&gt;
&lt;p&gt;Emscripten can generate asm.js code and wasm code, and they can generate HTML for testing JS/wasm with a console which displays result of evaluation.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;emcc simple.cpp -o simple.html -s &quot;BINARYEN_METHOD='native-wasm'&quot; -s WASM=1 -O1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-o&lt;/code&gt; specify output for generated file.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-o simple.js&lt;/code&gt;, generates javascript code, which you can invoke for example by using nodejs &lt;code class=&quot;highlighter-rouge&quot;&gt;node simple.js&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-o simple.html&lt;/code&gt;, generates HTML for testing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt; javascript code generation option.
    &lt;ul&gt;
      &lt;li&gt;BINARYEN_METHOD=’interpret-binary’ - force usage of wasm interpreter, &lt;a href=&quot;https://github.com/kripken/emscripten/wiki/WebAssembly&quot;&gt;read-more&lt;/a&gt;, if your platform doesn’t support webassembly(this method &lt;strong&gt;much&lt;/strong&gt; slower than native support).&lt;/li&gt;
      &lt;li&gt;BINARYEN_METHOD=’native-wasm,asmjs’ - will try native support, and if fail will use asm.js.&lt;/li&gt;
      &lt;li&gt;WASM=1 or BINARYEN=1 generate &lt;code class=&quot;highlighter-rouge&quot;&gt;*.wasm&lt;/code&gt; code.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-O1&lt;/code&gt; enable LLVM optimization, by default all optimization disabled.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Os&lt;/code&gt; enabling &lt;em&gt;super&lt;/em&gt; optimization.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pleas take a look at &lt;a href=&quot;https://kripken.github.io/emscripten-site/docs/tools_reference/emcc.html&quot;&gt;this page&lt;/a&gt; with full list of arguments for &lt;code class=&quot;highlighter-rouge&quot;&gt;emcc&lt;/code&gt; tool.
&lt;img src=&quot;http://i.imgur.com/LHk48Lh.png&quot; alt=&quot;simple.cpp&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;compile-into-js-file&quot;&gt;Compile into js file&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;emcc simple.cpp -o simple.js -s &quot;BINARYEN_METHOD='native-wasm'&quot; -s WASM=1 -Os
echo &quot;&amp;lt;script src='./simple.js'&amp;gt;&amp;lt;/script&amp;gt;&quot; &amp;gt; index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;And after opening file &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; in the browser I have: 
&lt;img src=&quot;http://i.imgur.com/WG77gkS.png&quot; alt=&quot;index.html&quot; /&gt;&lt;/p&gt;

&lt;p&gt;But when I trying run it in the node.js I have an error :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node simple.js
trying binaryen method: native-wasm
no native wasm support detected
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;It seems nodejs doesn’t have and wasm interpreter, we need compile to asm.js &lt;code class=&quot;highlighter-rouge&quot;&gt;-s &quot;BINARYEN_METHOD='native-wasm,asm.js'&quot;&lt;/code&gt; or with force using interpreter &lt;code class=&quot;highlighter-rouge&quot;&gt;-s -BINARYEN_METHOD='interpret-binary'&lt;/code&gt;. I prefer asm.js because of performance(force using interpret much slower than asm.js).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; emcc simple.cpp -o simple.js -s &quot;BINARYEN_METHOD='native-wasm,asmjs'&quot; -s WASM=1 -Os
&amp;gt; time node simple.js 
trying binaryen method: native-wasm
no native wasm support detected
trying binaryen method: asmjs
binaryen method succeeded.
Shuffled array
14 13 7 4 0 16 9 12 2 19 10 18 5 3 8 1 17 6 11 15 
Sorted array
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 
node simple.js  0.17s user 0.03s system 97% cpu 0.197 total
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;how-webassembly-works&quot;&gt;How webassembly works?&lt;/h2&gt;
&lt;p&gt;As I said above wasm using stack machine model on the hood, that helps run code faster and efficient.&lt;/p&gt;

&lt;h3 id=&quot;stack-machine&quot;&gt;Stack machine&lt;/h3&gt;
&lt;p&gt;A stack machine is a type of computer, but &lt;em&gt;wasm&lt;/em&gt; just imitate stack machine. This type of ‘computer’ has only two operations: push, pop and some computation with poped values like operation add(+). As you might have guessed stack machine using [stack aka LIFO](https://en.wikipedia.org/wiki/Stack_(abstract_data_type) inside.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Lifo_stack.png/700px-Lifo_stack.png&quot; alt=&quot;Stack&quot; /&gt;
&lt;em&gt;Stack ilustration&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A stack machine is easy to understand and it has a lot of advantages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Each operation pop’s and push’s from the same place.&lt;/li&gt;
  &lt;li&gt;Uniform compiler scheme&lt;/li&gt;
  &lt;li&gt;Very compact code&lt;/li&gt;
  &lt;li&gt;Simple compiler, because of uniform compiler scheme&lt;/li&gt;
  &lt;li&gt;Simple interpreter&lt;/li&gt;
  &lt;li&gt;Fast operation access&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;stack-machine---compilation&quot;&gt;Stack machine - compilation&lt;/h4&gt;
&lt;p&gt;Let’s imagine we need compile this expression &lt;code class=&quot;highlighter-rouge&quot;&gt;(a + b) * c - d&lt;/code&gt;. Where &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;(- (* (+ a b) c) d)&lt;/code&gt;.
Syntax tree will look like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/rhKI5Hh.png&quot; alt=&quot;syntax tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After compilation, generated code will look like :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUSH(a)
PUSH(b)
PUSH(POP() + POP())
PUSH(c)
PUSH(POP() * POP())
PUSH(d)
PUSH(POP() - POP())
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Now evaluate this code so easily, like play chess without any chessman :) Evaluation:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[a]
[a,b]
[(a+b)]
[(a+b),c]
[(a+b)*c]
[(a+b)*c,d]
[(a+b)*c - d]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Here I just illustrate how our stack will look like in every step of evaluation code.&lt;/p&gt;

&lt;h4 id=&quot;instructions&quot;&gt;Instructions&lt;/h4&gt;
&lt;p&gt;Each function contains list of instructions, which can be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Control instruction - loops, if/else conditions, return statement, blocks, branches.&lt;/li&gt;
  &lt;li&gt;Simple instruction - is simple instruction, like add, subtract, multiply, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#CONTROL INSTRUCTIONS
for i in range 1..5
	...
end
#SIMPLE INSTRUCTION
1 + 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Most computation in wasm use stack of values, but loops, conditions expressed in structured constructs. You can read more &lt;a href=&quot;http://webassembly.org/docs/semantics/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;storing-data&quot;&gt;Storing data&lt;/h4&gt;
&lt;p&gt;WASM has 4 types of data:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i32&lt;/code&gt; - integer 32 bit &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;i64&lt;/code&gt; - integer 64 bit &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;f32&lt;/code&gt; - float 32 bit &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;f64&lt;/code&gt; - float 64 bit &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Variables can be &lt;em&gt;global&lt;/em&gt; or &lt;em&gt;local&lt;/em&gt;.&lt;br /&gt;
&lt;strong&gt;Local&lt;/strong&gt; variables stored inside the function. Each function has pre-declared number of variable, and each of varialbe has type and initialized by default by +0. for float, 0 for integer, except &lt;em&gt;input fuction argument&lt;/em&gt; variables. Also wasm has function for interaction with variables, like:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_local&lt;/code&gt; - return local variable&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set_local&lt;/code&gt; - set local variable&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tee_local&lt;/code&gt; - set variable and return set value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Global&lt;/strong&gt; can be mutable or immutable, also you can &lt;a href=&quot;http://webassembly.org/docs/modules/#imports&quot;&gt;import them&lt;/a&gt; or &lt;a href=&quot;http://webassembly.org/docs/modules/#global-section&quot;&gt;define inside the module&lt;/a&gt;, and ofc you can access global variables them by using methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_global&lt;/code&gt; - get global value&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set_global&lt;/code&gt; - set global value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Generation result value&lt;/strong&gt;
In any high-level language it means generate constant variable &lt;code class=&quot;highlighter-rouge&quot;&gt;const int i = 5&lt;/code&gt;, this code will generate the constant variable type of integer. In wasm, you can generate variable by using &lt;code class=&quot;highlighter-rouge&quot;&gt;%TYPE%.const&lt;/code&gt; keyword, where &lt;code class=&quot;highlighter-rouge&quot;&gt;%TYPE&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;i64&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i32&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f64&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;f32&lt;/code&gt;, for example:
&lt;code class=&quot;highlighter-rouge&quot;&gt;i64.const 15&lt;/code&gt; - create a constant variable with type of 64 bit integer and assign value 15 to this const.
&lt;strong&gt;Function calls&lt;/strong&gt;
Each function contains: &lt;em&gt;sequence of return types&lt;/em&gt;, and &lt;em&gt;sequence of input argument types&lt;/em&gt;. A function doesn’t support varargs. To call function use &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; keyword, where argument is function index in &lt;a href=&quot;http://webassembly.org/docs/modules/#function-index-space&quot;&gt;function index space&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;wasm-binary-code-example&quot;&gt;WASM binary code example&lt;/h4&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;C++&lt;/th&gt;
    &lt;th&gt;Binary&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;pre&gt;
int factorial(int n) {
  if (n == 0)
    return 1;
  else
    return n * factorial(n-1);
}&lt;/pre&gt;&lt;/td&gt;
    &lt;td&gt;&lt;pre&gt;
20 00
42 00
51
04 7e
42 01
05
20 00
20 00
42 01
7d
10 00
7e
0b&lt;/pre&gt;&lt;/td&gt;
    &lt;td&gt;&lt;pre&gt;
get_local 0
i64.const 0
i64.eq
if i64
    i64.const 1
else
    get_local 0
    get_local 0
    i64.const 1
    i64.sub
    call 0
    i64.mul
end&lt;/pre&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/WebAssembly/design/blob/master/TextFormat.md&quot;&gt;Binary code can be easily translated into text format&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here was I try to show stack in each line of code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  get_local 0     # [n]
2.  i64.const 0	   # [n,0]
3.  i64.eq          # [n == 0]
4.  if i64          # n == 0 ?
5.     i64.const 1 # [1]
6.  else
7.     get_local 0 # [n]
8.     get_local 0 # [n, n]
9.     i64.const 1 # [n, n, 1]
10.    i64.sub     # [n, n - 1]
11.    call 0      # [n, fibonaci(n-1)]
12.    i64.mul     # [n * fibonaci(n - 1)]
13. end             
# returs 1 or n * fibonaci(n - 1), depends on if-else statement
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;On the first line &lt;code class=&quot;highlighter-rouge&quot;&gt;get_local 0&lt;/code&gt; get the local variable by index 0, &lt;code class=&quot;highlighter-rouge&quot;&gt;i64.const 0&lt;/code&gt; - create constant variable with value 0, &lt;code class=&quot;highlighter-rouge&quot;&gt;i64.eq&lt;/code&gt; - checking last two values in the stack( the result of evaluation &lt;code class=&quot;highlighter-rouge&quot;&gt;get_local 0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;i64.const 0&lt;/code&gt;), and put the result in a stack. Condition line if: &lt;code class=&quot;highlighter-rouge&quot;&gt;if i64&lt;/code&gt; - popping a value from the stack and checking value, if a condition is true pushing in the stack value 1, otherwise going to line 7. Pushing values into the stack on line 7-9, making subtraction, &lt;code class=&quot;highlighter-rouge&quot;&gt;call 0&lt;/code&gt; calls function by index 0 and put the result of the evaluation in the stack. Line 12 multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;call 0&lt;/code&gt; and n. And at end of the function, we return the result.&lt;/p&gt;

&lt;p&gt;In the next blog post, we will dive into webassembly code,and run interesting benchmarks.&lt;/p&gt;</content><author><name></name></author><summary type="html">WebAssembly aka wasm is an efficient low-level bytecode format for compilation to the web browsers, initial aim for wasm is compilation C/C++ code, but also other languages are supported such as Rust. Wasm allows run code faster and efficient, thanks to wasm code is stack machine. Wasm can be interpreted as the game changer for the web, which compiles C++/C into byte code and it can be run with near-native performance, it’s amazing!</summary></entry><entry><title type="html">Road to tree style functional language with C++{11} initializer list constructor, move constructor and variadic templates (Part 0)</title><link href="/cpp/2017/04/26/designing-and-implementation-tree-style-functional-language-and-c11-initializer-list-constructor.html" rel="alternate" type="text/html" title="Road to tree style functional language with C++{11} initializer list constructor, move constructor and variadic templates (Part 0)" /><published>2017-04-26T00:00:00-04:00</published><updated>2017-04-26T00:00:00-04:00</updated><id>/cpp/2017/04/26/designing-and-implementation-tree-style-functional-language-and-c11-initializer-list-constructor</id><content type="html" xml:base="/cpp/2017/04/26/designing-and-implementation-tree-style-functional-language-and-c11-initializer-list-constructor.html">&lt;h2 id=&quot;initializer_list&quot;&gt;Initializer_list&lt;/h2&gt;
&lt;p&gt;C++{11} bring into old c++ world a lot of exciting new features! One of this features is [std::initializer_list&lt;T&gt;](http://en.cppreference.com/w/cpp/utility/initializer_list). This new data structure is just a lightweight proxy object that provides access to the array of objects of type `const T`, in few words it's just array but not std::array. Using this data structure with keyword `auto` so easy and cool like drive a supercar.&lt;/T&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//arr is std::initializer_list&amp;lt;int&amp;gt;
auto arr = {1,2,3,4,5};
for(auto&amp;amp; elem: arr){
	std::cout&amp;lt;&amp;lt;elem&amp;lt;&amp;lt;' '; //will print 1 2 3 4 5
}
//OR
for(auto&amp;amp; val: {1,3,5,7,11}){
	std::cout&amp;lt;&amp;lt;val&amp;lt;&amp;lt;' '; //will print 1 3 5 7 11
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Wow, it’s really easy! By default, if you write auto with &lt;em&gt;braced-init-list(&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;)&lt;/em&gt; as we can see in the code above, you create a std::initializer_list&lt;T&gt; instance. But c++{11} went further and add this feature to [list-initialization](http://en.cppreference.com/w/cpp/language/list_initialization) like function call, and assignment expression when argument is `std::initializer_list&lt;T&gt;`. But my favorite feature is using std::initializer_list&lt;T&gt; with constructors, this will make it possible to do something like this:&lt;/T&gt;&lt;/T&gt;&lt;/T&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; vec {1,2,3,4,5,6,7}; //constructor
std::vector&amp;lt;int&amp;gt; vec_1 = {1,2,3,4,5,6,7}; //assigment
auto vec_2 = vector&amp;lt;int&amp;gt;{1,2,3,4,5,6}; //constructor
auto vec_3 = vector&amp;lt;int&amp;gt;({1,2,3,4,5,6}); //constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;All of this 4 vectors will contain the same values, and it’s really easy to initialize objects in this way. By default, if you declare &lt;code class=&quot;highlighter-rouge&quot;&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; in your function or constructor as an input argument, compiler prefer this function instead of an overloaded function with the same types and numbers of arguments.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; vec (10,20); //10 elements, each is 20 
vector&amp;lt;int&amp;gt; vec {10,20}; //2 elements, 10 and 20
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;As we can see above, when we use &lt;em&gt;braced-init-list&lt;/em&gt; compiler prefer call &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector(std::initializer_list&amp;lt;T&amp;gt;)&lt;/code&gt; constructor instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector(int _a, int _n)&lt;/code&gt;. Let’s try create our own structure!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;
class Container{
private:
    std::vector&amp;lt;T&amp;gt; vec;
public:
    /**
     * Create Container from initializer_list
     * @param list initializer_list
     */
    Container(const std::initializer_list&amp;lt;T&amp;gt;&amp;amp; list){
        this-&amp;gt;append(list);
    }
    /**
     * Create Container with default constructed n elements
     * @param size The number of elements to initially create.
     * @param default_value Default value every element
     */
    Container(size_t size, T default_value){
        vec = std::vector&amp;lt;T&amp;gt;(size, default_value);
    }
    /**
     * Append list to end of container
     * @param list appending list 
     * @return pointer to current container
     */
    Container&amp;amp; append(const std::initializer_list&amp;lt;T&amp;gt;&amp;amp; list){
        this-&amp;gt;vec.insert(this-&amp;gt;vec.end(), list.begin(), list.end());
        return *this;
    }
    /**
     * Get element by index
     * @param index index of element
     * @return reference to element
     */
    T&amp;amp;operator[](const int&amp;amp; index){
        //TODO add bounding checks
        return this-&amp;gt;vec[abs(index) % this-&amp;gt;vec.size()]; //cycle
    }
};

...

Container&amp;lt;int&amp;gt; container (10,555);
container.append({5,6,7,8});
for(auto i = 0;i &amp;lt; container.size();i++){
    std::cout&amp;lt;&amp;lt;container[i]&amp;lt;&amp;lt;' ';
}
std::cout&amp;lt;&amp;lt;std::endl;
//will print: 555 555 555 555 555 555 555 555 555 555 5 6 7 8 

Container&amp;lt;int&amp;gt; container_1 {10,555};
container_1.append({5,6,7,8});
for(auto i = 0;i &amp;lt; container_1.size();i++){
    std::cout&amp;lt;&amp;lt;container_1[i]&amp;lt;&amp;lt;' ';
}
//will print 10 555 5 6 7 8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;move-constructor&quot;&gt;Move constructor&lt;/h2&gt;

&lt;p&gt;If you define class or structure in C++{98} compiller generate 4 member function for you :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Default constructor&lt;/li&gt;
  &lt;li&gt;Desctructor&lt;/li&gt;
  &lt;li&gt;Copy constructor (deleted if class contains move operations)&lt;/li&gt;
  &lt;li&gt;Copy assigment operator (deleted if class contains move operations)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In new c++{11} you will have new one special member functions :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_constructor&quot;&gt;Move constructor&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/move_assignment&quot;&gt;Move assigment operator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These members will be generated if the class contains no user-declared copy operation, destructor or move operations. Each of this function performs memberwise moving of non-static data members.&lt;/p&gt;

&lt;p&gt;Let’s take a look at default move constructor:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person {
public:
    std::string name;
    //First copy constructor
    Person(const std::string&amp;amp; name):name(name){
    }
    Person(Person&amp;amp;&amp;amp; person) = delete; //delete move constructor
};
class Glass{
public:
    std::string name;
    //First copy constructor
    Glass(std::string&amp;amp;&amp;amp; name):name(std::move(name)){

    }
    //Second move constructor
    Glass(const std::string&amp;amp; name):name(name){

    }
};

...

Person person {&quot;Alfred&quot;}; // call first constructor
Glass red_glass {&quot;brow-blue&quot;}; //call second constuctor

auto newone_red_glass = std::move(red_glass); //call second contructor
//auto new_person = std::move(person); // do not compile cause we delete move constructor

std::cout&amp;lt;&amp;lt;&quot;Red glass name : &quot; &amp;lt;&amp;lt; red_glass.name&amp;lt;&amp;lt; std::endl;  
//will print `Red glass name :`
    
std::cout&amp;lt;&amp;lt;&quot;New one Red glass name : &quot; &amp;lt;&amp;lt; newone_red_glass.name&amp;lt;&amp;lt; std::endl; 
//will print `New one Red glass name : brow-blue`

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;As we can see after move operation old value will be moved to new one, in some cases, it’s better than create a copy (like reallocation memory in std::vector c++{11}) cause it’s faster than create a copy.&lt;/p&gt;

&lt;h2 id=&quot;variadic-template&quot;&gt;Variadic template&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/parameter_pack&quot;&gt;Variadic template&lt;/a&gt; - are a template that takes a variable number of templates. It’s made possible pass different number arguments with different types to function (kind of &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/parameter_pack&quot;&gt;varargs&lt;/a&gt; in java). This feature can be used if you want to implement custom &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt; function, which retrieves a different number of arguments with different types. Also, all logic will be resolved on &lt;strong&gt;compile-time&lt;/strong&gt;!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//1 argument
template &amp;lt;typename T&amp;gt;
T sum(T value){   
    return value;
}
// Different number of arguments
template &amp;lt;typename T, typename ...Args&amp;gt;
T sum(T value, Args... rest){
    return value + sum(rest...);
};

...

std::cout&amp;lt;&amp;lt;sum(1.1f,2,3,6.0f,0.75); 
//will print: 12.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; function, calculate sum of input arguments, by recursion. First function &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; will be called if number of arguments = 1, but if number of arguments will be more than 2, the second function will be called. As you can see we pass the first argument as type float, but second is int. And the output will be cast to type float, cause it’s frirt argument. Let’s try test it :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;limits&amp;gt;  //for std::cout.precision
#include &amp;lt;typeinfo&amp;gt; //typeid(t).name

...
std::cout.precision(std::numeric_limits&amp;lt; double &amp;gt;::max_digits10);

auto sum_int = sum(2, 1.1f,2,3,6.0f,0.75, static_cast&amp;lt;double &amp;gt;(5.0 + 1e-12));
std::cout&amp;lt;&amp;lt;&quot;Sum; var sum_int: &quot;&amp;lt;&amp;lt;sum_int&amp;lt;&amp;lt;std::endl;
std::cout&amp;lt;&amp;lt;&quot;Type of sum_int: &quot;&amp;lt;&amp;lt; typeid(sum_int).name()&amp;lt;&amp;lt;std::endl;

auto sum_float = sum(2.0f, 1.1f,2,3,6.0f,0.75, static_cast&amp;lt;double &amp;gt;(5.0 + 1e-12));
std::cout&amp;lt;&amp;lt;&quot;Sum; var sum_float: &quot;&amp;lt;&amp;lt;sum_float&amp;lt;&amp;lt;std::endl;
std::cout&amp;lt;&amp;lt;&quot;Type of sum_float: &quot;&amp;lt;&amp;lt; typeid(sum_float).name()&amp;lt;&amp;lt;std::endl;

auto sum_double = sum(static_cast&amp;lt;double &amp;gt;(5.0 + 1e-12),2, 1.1f,2,3,6.0f,0.75);
std::cout&amp;lt;&amp;lt;&quot;Sum; var sum_double: &quot;&amp;lt;&amp;lt;sum_double&amp;lt;&amp;lt;std::endl;
std::cout&amp;lt;&amp;lt;&quot;Type of sum_double: &quot;&amp;lt;&amp;lt; typeid(sum_double).name()&amp;lt;&amp;lt;std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Ouput:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sum; var sum_int: 19
Type of sum_int: i
Sum; var sum_float: 19.100000381469727
Type of sum_float: f
Sum; var sum_double: 19.000000000001002
Type of sum_double: d
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Yes, we was be correct, output result will be casted to first value!&lt;/p&gt;

&lt;p&gt;Also we can define constructor with variadic templates, and create something cool! Like this :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Pzo5Aaz.png&quot; alt=&quot;Value and sum derived from value_base&quot; /&gt;&lt;/p&gt;

&lt;p&gt;VALUE_BASE is a just interface, VALUE and SUM override from them. So VALUE and SUM have function &lt;code class=&quot;highlighter-rouge&quot;&gt;getVal&lt;/code&gt;. Now we can easily build hierarchic expression evaluator, actually, I am not sure about this title.&lt;/p&gt;

&lt;p&gt;Code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;numeric&amp;gt;
using namespace std;

/*
 * Everything has value, base class for those classes who are so good at
 */
class VALUE_BASE{
public:
    /**
     * Get value
     * @return int value
     */
    virtual int getVal() = 0;
    virtual ~VALUE_BASE() = default;

    operator int(){
        return this-&amp;gt;getVal();
    }
};


/**
 * We check if type U is base of VALUE_BASE
 * @tparam U type which will be checked.
 */
template &amp;lt;typename U&amp;gt;
void is_base_of_valuebase_assert(){
    static_assert(std::is_base_of&amp;lt;VALUE_BASE, U&amp;gt;::value, &quot;Type is not instance of VALUE_BASE&quot;);
}
/**
 * We if type U and V is base of VALUE_BASE
 * @tparam U type which will be checked.
 * @tparam V type which will be checked.
 */
template &amp;lt;typename U, typename V&amp;gt;
void is_base_of_valuebase_assert(){
    static_assert(std::is_base_of&amp;lt;VALUE_BASE, U&amp;gt;::value, &quot;The first argument must be a base class of VALUE_BASE&quot;);
    static_assert(std::is_base_of&amp;lt;VALUE_BASE, V&amp;gt;::value, &quot;Second argument must be a base class of VALUE_BASE&quot;);
}
/**
 * VALUE - class which derived, contain value, and implement function getVal
 */
class VALUE:public VALUE_BASE{
int value;
public:
    /**
     * Get stored value
     * @return current value
     */
    virtual int getVal() override {
        return this-&amp;gt;value;
    }


    virtual ~VALUE() override {
        std::cout&amp;lt;&amp;lt;&quot;destroying VALUE object, which contains :&quot;
                 &amp;lt;&amp;lt;this-&amp;gt;getVal()&amp;lt;&amp;lt;&quot; as value.&quot;&amp;lt;&amp;lt;std::endl;;
    }

    /*
     * We delete this class couse we useonly moving operations!
     */
    VALUE(const VALUE &amp;amp;vval) = delete;

    /*
     * Default move and move assigment contructors
     */
    VALUE(VALUE&amp;amp;&amp;amp; v ) {
        this-&amp;gt;value = std::move(v.value);
        v.value = -1;//we cannot destroy passed object, so set it into -1
        std::cout&amp;lt;&amp;lt;&quot;moving VALUE object, which contains :&quot;
                 &amp;lt;&amp;lt;this-&amp;gt;getVal()&amp;lt;&amp;lt;&quot; as value&quot; &amp;lt;&amp;lt;std::endl;
    }
    VALUE&amp;amp;operator =(VALUE&amp;amp;&amp;amp;) = default;
    /*
     * store passed int value
     */
    VALUE(const int &amp;amp; val){
        this-&amp;gt;value = val;
        std::cout&amp;lt;&amp;lt;&quot;creating VALUE object, which contains :&quot;
                 &amp;lt;&amp;lt;this-&amp;gt;getVal()&amp;lt;&amp;lt;&quot; as value.&quot;&amp;lt;&amp;lt;std::endl;;

    }
};

/*
 * Calculate sum of objects
 * Store multiple references , which direct to classes whose implement getVal function
 */

class SUM: public VALUE_BASE{
private:

    template &amp;lt;typename T_VALUE&amp;gt;
    void init(T_VALUE&amp;amp;&amp;amp; value){
        is_base_of_valuebase_assert&amp;lt;T_VALUE&amp;gt;();

        this-&amp;gt;sum_arguments.push_back(std::make_shared&amp;lt;T_VALUE&amp;gt;(std::move(value)));
    }
    template &amp;lt;typename T_VALUE, typename... Args&amp;gt;
    void init(T_VALUE&amp;amp;&amp;amp; value, Args&amp;amp;&amp;amp;... rest){
        is_base_of_valuebase_assert&amp;lt;T_VALUE&amp;gt;();
        this-&amp;gt;sum_arguments.push_back(std::make_shared&amp;lt;T_VALUE&amp;gt;(std::move(value)));
        init(std::move(rest)...);
    };
public:
    std::vector&amp;lt; std::shared_ptr&amp;lt;VALUE_BASE&amp;gt; &amp;gt; sum_arguments;

    void log(std::string operation){
        std::cout &amp;lt;&amp;lt; operation&amp;lt;&amp;lt;&quot; SUM object, which contains :&quot;;

        int value_counter = 0;
        for(auto&amp;amp; v: this-&amp;gt;sum_arguments){
            std::cout&amp;lt;&amp;lt;(v == nullptr? &quot;nullptr&quot;: std::to_string(v-&amp;gt;getVal())) &amp;lt;&amp;lt; &quot; as &quot;&amp;lt;&amp;lt; std::to_string(++value_counter) &amp;lt;&amp;lt;&quot; value, &quot;;
        }
       std::cout&amp;lt;&amp;lt; std::endl;
    }

    virtual ~SUM(){
            log(&quot;destroying&quot;);
    }

    /**
     * Move data from data which was be passes as rvalue, to our std::vector of refferences.
     * @tparam T_VALUE1 should be derived from VALUE_BASE
     * @param value1 value which will be used as arguments for sum
     */
    template &amp;lt;typename T_VALUE1&amp;gt;
    SUM(T_VALUE1&amp;amp;&amp;amp; value){
        is_base_of_valuebase_assert&amp;lt;T_VALUE1&amp;gt;();
        this-&amp;gt;init(std::move(value));

        this-&amp;gt;log(&quot;creating&quot;);
    };

    template &amp;lt;typename T_VALUE, typename... Args&amp;gt;
    SUM(T_VALUE&amp;amp;&amp;amp; value, Args&amp;amp;&amp;amp;... rest){
        this-&amp;gt;init(std::move(value), rest...);

        this-&amp;gt;log(&quot;creating&quot;);
    };

    SUM(const SUM&amp;amp;) = delete;

    SUM(SUM&amp;amp;&amp;amp; sum){
        //Shared ptr = works like std::move
        this-&amp;gt;sum_arguments = std::move(sum.sum_arguments);

        this-&amp;gt;log(&quot;moving&quot;);

    }

    /**
     * Calculate sum
     * @return sum
     */
    virtual int getVal() override {
        return std::accumulate(this-&amp;gt;sum_arguments.begin(), this-&amp;gt;sum_arguments.end(), 0,
        [](const int&amp;amp;a, auto&amp;amp; value){
            return a + value-&amp;gt;getVal();
        });
        
    }

};

int main(){
    //Wow we can make something like this!
    auto sum = SUM{
            VALUE{10}, //First argument derived from VALUE_BASE
            SUM{       //SUM also derived from VALUE_BASE
                    VALUE{5},
                    VALUE{11}
            }
    };
    std::cout&amp;lt;&amp;lt;&quot;SUM = &quot;&amp;lt;&amp;lt;sum.getVal()&amp;lt;&amp;lt;std::endl; //will be printed 26
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Will be printed:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. creating VALUE object, which contains :10 as value.
2. creating VALUE object, which contains :5 as value.
3. creating VALUE object, which contains :11 as value.
4. moving VALUE object, which contains :5 as value
5. moving VALUE object, which contains :11 as value
6. creating SUM object, which contains :5 as 1 value, 11 as 2 value, 
7. moving VALUE object, which contains :10 as value
8. moving SUM object, which contains :5 as 1 value, 11 as 2 value, 
9. creating SUM object, which contains :10 as 1 value, 16 as 2 value, 
10. destroying SUM object, which contains :
11. destroying VALUE object, which contains :-1 as value.
12. destroying VALUE object, which contains :-1 as value.
13. destroying VALUE object, which contains :-1 as value.
14. SUM = 26
15. destroying SUM object, which contains :10 as 1 value, 16 as 2 value, 
16. destroying VALUE object, which contains :10 as value.
17. destroying SUM object, which contains :5 as 1 value, 11 as 2 value, 
18. destroying VALUE object, which contains :5 as value.
19. destroying VALUE object, which contains :11 as value.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Let’s take a look at the output, firstly we creating a VALUE leafs (lines 1-3). Moving leafs 5 and 11 into SUM object (4-6). Moving value and SUM object into the second sum(main sum) lines 7 - 10. After we see how all variables which were &lt;a href=&quot;http://thbecker.net/articles/rvalue_references/section_01.html&quot;&gt;rhs&lt;/a&gt; are destroyed(10-13). Get result at line 14. And after that will be destroyed all object &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; in the main function, cause function is destroyed.&lt;/p&gt;

&lt;p&gt;But we can create a cool concept language which will look like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto Fib = FUNC{
	NAME{
			&quot;fibonaci&quot;
	},
	ARGS{
			ARG&amp;lt;int&amp;gt;(&quot;first&quot;,0),
			ARG&amp;lt;int&amp;gt;(&quot;second&quot;, 1),
			ARG&amp;lt;int&amp;gt;(&quot;n&quot;, 10)
	},
	BODY{
		VAR{
			&quot;SUM&quot;,
			PLUS(&quot;first&quot;, &quot;second&quot;)
		},
		VAR{
			&quot;N&quot;,
			MINUS(&quot;n&quot;, 1);
		},
		RETURN{
			IF{
				EQUAL{&quot;N&quot;, 1},
				1
			},
			ELIF{
				EQUAL {&quot;N&quot;, 2},
				1
			},
			ELSE{
				CALL_FUNC(&quot;fibonaci&quot;, &quot;second&quot;, &quot;SUM&quot;, &quot;N&quot;)
			}
		}
	}
}
std::cout&amp;lt;&amp;lt;Fib()&amp;lt;&amp;lt;std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;We create an object function for calculation &lt;em&gt;fibonacci number&lt;/em&gt;, this object/function has a name, input arguments, and body. In the body, we define variables, makes some calculation, return value which depends on some condition or returns result of recursion call. Actually, by using this approach, we can implement more coolest algorithms like quick sort, or declare recursive data structures like trees. Yes, we will try to implement this function in next blog post!&lt;/p&gt;</content><author><name></name></author><summary type="html">Initializer_list C++{11} bring into old c++ world a lot of exciting new features! One of this features is [std::initializer_list](http://en.cppreference.com/w/cpp/utility/initializer_list). This new data structure is just a lightweight proxy object that provides access to the array of objects of type `const T`, in few words it's just array but not std::array. Using this data structure with keyword `auto` so easy and cool like drive a supercar.</summary></entry><entry><title type="html">Multifunctional enumerator, std::any{C++17} and templates.</title><link href="/cpp/2017/04/18/multifunctional-enumerator-stdanyc17-and-templates.html" rel="alternate" type="text/html" title="Multifunctional enumerator, std::any{C++17} and templates." /><published>2017-04-18T00:00:00-04:00</published><updated>2017-04-18T00:00:00-04:00</updated><id>/cpp/2017/04/18/multifunctional-enumerator-stdanyc17-and-templates</id><content type="html" xml:base="/cpp/2017/04/18/multifunctional-enumerator-stdanyc17-and-templates.html">&lt;h1 id=&quot;multifunctional-enumerator-stdanyc17-and-templates&quot;&gt;Multifunctional enumerator, std::any{C++17} and templates.&lt;/h1&gt;

&lt;p&gt;In many cases, you will wonder to enumerate all possible candidates in the dictionary, by the way, it’s using in &lt;a href=&quot;https://en.wikipedia.org/wiki/Brute-force_search&quot;&gt;Brute-force search&lt;/a&gt;. Also, enumerations can be using in &lt;a href=&quot;https://en.wikipedia.org/wiki/Permutation&quot;&gt;permutation of objects&lt;/a&gt;. But first things first.&lt;/p&gt;

&lt;p&gt;Let’s imagine you have a locked door, and the door will be opened if you give correct user information (age, person height, and secret letter).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: you forget your height and your secret letter, but you know approximately your height [180 - 190] centimeter.
 You have 3 options to unlock this door:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;try better to remember all info&lt;/li&gt;
  &lt;li&gt;restore access&lt;/li&gt;
  &lt;li&gt;enumerate all possible candidate in the dictionary.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In our case we have the only 3rd option, we need to take first possible height value and enumerate all possible secret keys, take second one possible key and keep going on.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Height cm.&lt;/th&gt;
      &lt;th&gt;Secret letter&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;180.0&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180.0&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180.0&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180.0&lt;/td&gt;
      &lt;td&gt;Z&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180.1&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;180.1&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;….&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;190.0&lt;/td&gt;
      &lt;td&gt;Z&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Enumaration bounds:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Secret letter: ‘A’,’B’, …‘Z’&lt;/li&gt;
  &lt;li&gt;Height sm. : 180.0, 180.1, 180.2, 180.3, … 190&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can compute total number of enumerations, it will be :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(total possible heights) * (total possible letters)
((190 - 180) * 10 + 1) * (Total length of english alphabet)
101 * 26
2626
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Let’s try to design interface for our future enumerator:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Enumerations::Enumerator()
        .addEnumeration(&quot;secret letter&quot;, Enumerations::Enumeration&amp;lt;char&amp;gt;('A', 'Z', 1))  //Lower bound 'A', upper bound 'Z', step 1
        .addEnumeration(&quot;height&quot;, Enumerations::Enumeration&amp;lt;double&amp;gt;(180.0, 190.0, 0.1 )) //LB 180, UB 190, step 0.1
        //Pass lambda function into enumeration function
        .enumerate([](Enumerations::EnumerationMap enumerationMap) {
            //Use current enumeration
            std::cout &amp;lt;&amp;lt; enumerationMap.get&amp;lt;char&amp;gt;(&quot;secret letter&quot;) &amp;lt;&amp;lt; ' '
                      &amp;lt;&amp;lt; enumerationMap.get&amp;lt;double&amp;gt;(&quot;height&quot;) &amp;lt;&amp;lt; std::endl;
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;class &lt;a href=&quot;enumeration-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Enumeration&lt;/code&gt;&lt;/a&gt; will play the role of the store for upper bound, lower bound, step and the current value of the enumeration. For enumeration through &lt;em&gt;height&lt;/em&gt; in our case &lt;code class=&quot;highlighter-rouge&quot;&gt;Enumeration&lt;/code&gt; will have 180.0 - as lower bound, 190.0 - upper bound, 0.1 step and current value will be lower bound, but in next state current value will be lower bound + step.&lt;/li&gt;
  &lt;li&gt;class &lt;a href=&quot;enumerator-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Enumerator&lt;/code&gt;&lt;/a&gt; will hold all &lt;code class=&quot;highlighter-rouge&quot;&gt;Enumeration&lt;/code&gt; class instances, and has function &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt; will receive a pointer to function or lambda as an input argument, and call them when new enumeration will be generated. This lambda should receive as input argument class instance &lt;code class=&quot;highlighter-rouge&quot;&gt;EnumerationMap&lt;/code&gt; which hold value for the current enumeration.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;class &lt;a href=&quot;enumerationmap-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EnumerationMap&lt;/code&gt;&lt;/a&gt; hold values for current enumeration,also they has function for insert value by &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string&lt;/code&gt; as key and &lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt; as value, function for get value by &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string&lt;/code&gt; key which will be converted to type which will be passed into function as template input argument.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;enumeration-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Enumeration&lt;/code&gt; class&lt;/h3&gt;

&lt;p&gt;As we can see we need a container with different data types, &lt;code class=&quot;highlighter-rouge&quot;&gt;Enumerations::Enumeration&amp;lt;TYPE&amp;gt;&lt;/code&gt;.
 We can store base class inside a container and insert derived template class into a container.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; class EnumerationBase {
    public:
        virtual ~EnumerationBase() {}

        EnumerationBase(const EnumerationBase &amp;amp;pb) = default;
        EnumerationBase() = default;

        virtual std::experimental::fundamentals_v1::any current() = 0;

        virtual void next() = 0;  // Go to next value
        virtual void reset() = 0; // Reset current value to start value
        virtual bool hasNext() = 0; // Check we have next value
    };

    template&amp;lt;class T&amp;gt;
    class Enumeration : public EnumerationBase {
    public:
        Enumeration(const Enumeration &amp;amp;pb) = default;
        Enumeration() = default;
        virtual ~Enumeration() = default;

        virtual std::experimental::fundamentals_v1::any current() override {
            return current_val;
        }

        virtual void next() override {
            if (!this-&amp;gt;hasNext()) {
                throw std::out_of_range(&quot;Current enumeration doesn't has next values&quot;);
            }
            current_val += step;
        }
        virtual void reset() override {
            this-&amp;gt;current_val = this-&amp;gt;start;
        }
        virtual bool hasNext() override {
            return current_val + step &amp;lt;= end;
        }
        Enumeration(T start, T end, T step) : start(start), current_val(start), end(end), step(step) {}
    private:
        T start;
        T end;
        T step;
        T current_val;
    };

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We will store &lt;code class=&quot;highlighter-rouge&quot;&gt;EnumerationBase&lt;/code&gt; in our container, but we will add derived &lt;code class=&quot;highlighter-rouge&quot;&gt;Enumeration&amp;lt;Type&amp;gt;&lt;/code&gt; to our container, where &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt; is object with implemented &lt;code class=&quot;highlighter-rouge&quot;&gt;+=&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; operators, like base types(&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;, etc).&lt;/p&gt;

&lt;p&gt;As you can see we added &lt;a href=&quot;http://en.cppreference.com/w/cpp/keyword/default&quot;&gt;default&lt;/a&gt; keyword after function definition. In few words, default tells to the compiler generate this function. In our case, we implement a destructor, and as we know if we define a destructor, copy constructor and copy assigned function will not be generated.&lt;/p&gt;

&lt;p&gt;Let’s take a look at current function which return &lt;code class=&quot;highlighter-rouge&quot;&gt;std::experimental::fundamentals_v1::any&lt;/code&gt;.
 &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/any&quot;&gt;any&lt;/a&gt; is container with single values of any type, it’s a new type from C++{17}.
 In our case we don’t know which type we should return from the polymorphic call, so we return &lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt; type.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; //Create vector with any objects as type, and initialize them string, and int values.
std::vector&amp;lt;std::experimental::fundamentals_v1::any&amp;gt; v {std::string(&quot;C++&quot;), 17};
//Convert from any type to concret type
std::cout&amp;lt;&amp;lt;std::experimental::fundamentals_v1::any_cast&amp;lt;std::string&amp;gt;(v[0])&amp;lt;&amp;lt;std::endl; //will print 'C++'
std::cout&amp;lt;&amp;lt;std::experimental::fundamentals_v1::any_cast&amp;lt;int&amp;gt;(v[1])&amp;lt;&amp;lt;std::endl;          //will print 17
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In a code above, I tried to show, how we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt; type. We create a vector with 2 &lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt; objects inside them which were be converted from &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; types, and at the end, we convert &lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt; objects back to &lt;code class=&quot;highlighter-rouge&quot;&gt;std::string&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; types.&lt;/p&gt;

&lt;h3 id=&quot;enumerator-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Enumerator&lt;/code&gt; class&lt;/h3&gt;
&lt;p&gt;It’s class for generate permutation, relying to &lt;code class=&quot;highlighter-rouge&quot;&gt;Enumeration&lt;/code&gt; class instances inside them. Hold 1 public function &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;, which receive as input argument pointer to function or lambda, it’s kind of &lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt; from JS world. For every new enumeration object fire callback with new enumeration.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void enumeration_callback(Enumerations::EnumerationMap enumerationMap){
	//First time will fired with height = 180.0, secret letter = 'A'
	//Second time with height = 180.0, secret letter = 'B'
	//Note it's for our case with locked door.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Implementation&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Enumerator {
public:
    template&amp;lt;typename Type&amp;gt;
    Enumerator &amp;amp;addEnumeration(std::string name, Enumeration&amp;lt;Type&amp;gt; enumeration) {
        this-&amp;gt;enumeration.push_back({name, std::make_unique&amp;lt;Enumeration&amp;lt;Type&amp;gt; &amp;gt;(enumeration)});
        return *this;
    }

    template&amp;lt;typename Callback&amp;gt;
    void enumerate(Callback callback) {
        this-&amp;gt;enumerate(0, this-&amp;gt;enumeration, callback);
    }


private:
    EnumerationObjects enumeration;
    template&amp;lt;typename Callback&amp;gt;
    void enumerate(int index_enumeration, EnumerationObjects &amp;amp;enumerations, Callback callback) {
        if (index_enumeration == enumerations.size()) {
            EnumerationMap enumerationMap;
            for (auto &amp;amp;p: enumerations) {
                enumerationMap.insert(p.first, p.second-&amp;gt;current());
            }
            if (!enumerationMap.empty())
                callback(enumerationMap);
            return;
        }
        while (enumerations[index_enumeration].second-&amp;gt;hasNext()) {
            enumerate(index_enumeration + 1, enumerations, callback);
            enumerations[index_enumeration].second-&amp;gt;next();
        }
        enumerate(index_enumeration + 1, enumerations, callback);
        enumerations[index_enumeration].second-&amp;gt;reset();
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;enumerationmap-class&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EnumerationMap&lt;/code&gt; class&lt;/h3&gt;
&lt;p&gt;It’s just proxy class for &lt;code class=&quot;highlighter-rouge&quot;&gt;std::map&amp;lt;std::string, std::experimental::fundamentals_v1::any&lt;/code&gt; class. This class contain current enumerations for current step in enumeration.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class EnumerationMap {
    using Container = std::map&amp;lt;std::string, std::experimental::fundamentals_v1::any&amp;gt;;
private:
    Container container;
public:
    template&amp;lt;typename Type&amp;gt;
    Type get(std::string name) {
        return std::experimental::fundamentals_v1::any_cast&amp;lt;Type&amp;gt;(this-&amp;gt;container[name]);
    }

    void insert(std::string name, std::experimental::fundamentals_v1::any val) {
        this-&amp;gt;container[name] = val;
    }

    bool empty() {
        return this-&amp;gt;container.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Nothing special except convenient conversion from &lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt; class instance to &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt; which will be passed as an input argument to function &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;all-together&quot;&gt;All together&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;experimental/any&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;stdexcept&amp;gt;

namespace Enumerations {
    class EnumerationBase {
    public:
        virtual ~EnumerationBase() {
        }

        EnumerationBase(const EnumerationBase &amp;amp;pb) = default;

        EnumerationBase() = default;

        virtual std::experimental::fundamentals_v1::any current() = 0;

        virtual void next() = 0;  // Go to next value
        virtual void reset() = 0; // Reset current value to start value
        virtual bool hasNext() = 0; // Check we have next value
    };

    using EnumerationObjects = std::vector&amp;lt;std::pair&amp;lt;std::string, std::unique_ptr&amp;lt;EnumerationBase&amp;gt; &amp;gt;&amp;gt;;

    template&amp;lt;class T&amp;gt;
    class Enumeration : public EnumerationBase {
    public:
        Enumeration(const Enumeration &amp;amp;pb) = default;

        Enumeration() = default;

        virtual ~Enumeration() = default;

        virtual std::experimental::fundamentals_v1::any current() override {
            return current_val;
        }

        virtual void next() override {
            if (!this-&amp;gt;hasNext()) {
                throw std::out_of_range(&quot;Current enumeration doesn't has next values&quot;);
            }
            current_val += step;
        }
        virtual void reset() override {
            this-&amp;gt;current_val = this-&amp;gt;start;
        }
        virtual bool hasNext() override {
            return current_val + step &amp;lt;= end;
        }
        Enumeration(T start, T end, T step) : start(start), current_val(start), end(end), step(step) {}
    private:
        T start;
        T end;
        T step;
        T current_val;
    };


    class EnumerationMap {
        using Container = std::map&amp;lt;std::string, std::experimental::fundamentals_v1::any&amp;gt;;
    private:
        Container container;
    public:
        template&amp;lt;typename Type&amp;gt;
        Type get(std::string name) {
            return std::experimental::fundamentals_v1::any_cast&amp;lt;Type&amp;gt;(this-&amp;gt;container[name]);
        }

        void insert(std::string name, std::experimental::fundamentals_v1::any val) {
            this-&amp;gt;container[name] = val;
        }

        bool empty() {
            return this-&amp;gt;container.empty();
        }
    };

    class Enumerator {
    public:
        template&amp;lt;typename Type&amp;gt;
        Enumerator &amp;amp;addEnumeration(std::string name, Enumeration&amp;lt;Type&amp;gt; enumeration) {
            this-&amp;gt;enumeration.push_back({name, std::make_unique&amp;lt;Enumeration&amp;lt;Type&amp;gt; &amp;gt;(enumeration)});
            return *this;
        }

        template&amp;lt;typename Callback&amp;gt;
        void enumerate(Callback callback) {
            this-&amp;gt;enumerate(0, this-&amp;gt;enumeration, callback);
        }


    private:
        EnumerationObjects enumeration;
        template&amp;lt;typename Callback&amp;gt;
        void enumerate(int index_enumeration, EnumerationObjects &amp;amp;enumerations, Callback callback) {
            if (index_enumeration == enumerations.size()) {
                EnumerationMap enumerationMap;
                for (auto &amp;amp;p: enumerations) {
                    enumerationMap.insert(p.first, p.second-&amp;gt;current());
                }
                if (!enumerationMap.empty())
                    callback(enumerationMap);
                return;
            }
            while (enumerations[index_enumeration].second-&amp;gt;hasNext()) {
                enumerate(index_enumeration + 1, enumerations, callback);
                enumerations[index_enumeration].second-&amp;gt;next();
            }
            enumerate(index_enumeration + 1, enumerations, callback);

            enumerations[index_enumeration].second-&amp;gt;reset();
        }
    };
}

int main(){
    Enumerations::Enumerator()
            .addEnumeration(&quot;secret letter&quot;, Enumerations::Enumeration&amp;lt;char&amp;gt;('A', 'Z', 1))
            .addEnumeration(&quot;height&quot;, Enumerations::Enumeration&amp;lt;double&amp;gt;(180.0, 190.0, 0.1 ))
            .enumerate([](Enumerations::EnumerationMap enumerationMap) {
                std::cout &amp;lt;&amp;lt; enumerationMap.get&amp;lt;char&amp;gt;(&quot;secret letter&quot;) &amp;lt;&amp;lt; ' '
                          &amp;lt;&amp;lt; enumerationMap.get&amp;lt;double&amp;gt;(&quot;height&quot;) &amp;lt;&amp;lt; std::endl;
            });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That is! We can use this enumerator in many cases, like for permutation, brute-forces, fill databases and list with fake data, generation random data, etc…&lt;/p&gt;</content><author><name></name></author><summary type="html">Multifunctional enumerator, std::any{C++17} and templates.</summary></entry><entry><title type="html">Metaprogramming and Constexpr c++{14}</title><link href="/cpp/2017/04/14/constexpr-c14-and-metprogramming.html" rel="alternate" type="text/html" title="Metaprogramming and Constexpr c++{14} " /><published>2017-04-14T00:00:00-04:00</published><updated>2017-04-14T00:00:00-04:00</updated><id>/cpp/2017/04/14/constexpr-c14-and-metprogramming</id><content type="html" xml:base="/cpp/2017/04/14/constexpr-c14-and-metprogramming.html">&lt;p&gt;One guy said ‘if there were award for the most confusing word in C++11, constexpr would probably win it.’, and he was be correct. So what the difference between &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; and regular &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;? &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; can be used in 2 cases - apply &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; to object and apply &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; to function. 
Let’s look both cases:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apply to object&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constexpr auto size = 10;
std::array&amp;lt;float, size&amp;gt; arr;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Your object will be assigned by constant calculated expression in a &lt;strong&gt;compile time&lt;/strong&gt;. It’s mean your variable size is just regular C++98 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;, and you can use this variable for like initialization static arrays.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apply to function&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constexpr auto DEBUG_VERSION = false; //constexpr object
constexpr auto calculateArrayLength() //C++14
{
		if(DEBUG_VERSION){
				return 20 * 30 - 70 * 10;
		}else{
				return 10;
		}
}
constexpr auto calculateArrayLength() //C++11
{
		//C++ doesnt support any other expressions inside constexpr function
		return DEBUG_VERSION? 20 * 30 - 70 * 10: 10;
}
...
constexpr auto stack_size = calculateArrayLength();
const std::array&amp;lt;float,stack_size&amp;gt; stack_area;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;As we can see - &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; indicate which function evaluation result can be calculated in compilation time. But using &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; + class function means we dont change any member variable of the class, as we can see below.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class String{
    using str_container = std::vector&amp;lt;char&amp;gt;;
private:
    str_container data;
public:
    String(){}
    String(std::string data){

        this-&amp;gt;data.resize(data.length() + 1);
        std::copy(data.c_str(), data.c_str() + data.length() + 1, this-&amp;gt;data.begin());
        this-&amp;gt;data.resize(data.length());//remove '\0' last character
    }
    String(const str_container&amp;amp; data):data(data){}

    String operator+(const String&amp;amp; rhs) const{ //We use imutable string way, so we do not change internal state (we add keyword const at end of function)
        str_container data_container(this-&amp;gt;data.size() + rhs.data.size() + 1);
        std::copy(this-&amp;gt;data.begin(),this-&amp;gt;data.end(), data_container.begin());
        std::copy(rhs.data.begin(), rhs.data.end(), data_container.begin() + this-&amp;gt;data.size());
        data_container.resize(data_container.size() - 1);//Resize
        return String(data_container);
    }
};

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;As we can see &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; always &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;, but &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; not always &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;constexpr Class functions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Yes, we can create constexpr class instances.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;array&amp;gt;
#include &amp;lt;iostream&amp;gt;
//1x2 Matrix
template &amp;lt;typename DataType&amp;gt;
class Vector2 {
public:
public:
    constexpr Vector2(){
    }
    constexpr Vector2(DataType x, DataType y):x(x), y(y){
    }

    DataType x;
    DataType y;
};

#define Vector2f Vector2&amp;lt;float&amp;gt;
using Vector2d = Vector2&amp;lt;double&amp;gt;; //Walk away old C++98 define!
using Vector2i = Vector2&amp;lt;int&amp;gt;;
using Vector2l = Vector2&amp;lt;long&amp;gt;;

//1x3 Matrix
template &amp;lt;typename DataType&amp;gt;
class Vector3: public Vector2&amp;lt;DataType&amp;gt;{
public:
    DataType z;
    constexpr Vector3(){

    }
    constexpr Vector3(DataType x, DataType y, DataType z): Vector2&amp;lt;DataType&amp;gt;(x,y), z(z){

    }
		// 3 keywords which containt 'const' keyword inside, hah
    constexpr auto operator+(const Vector3&amp;lt;DataType&amp;gt;&amp;amp; rhs) const{    
        return Vector3&amp;lt;DataType&amp;gt;(this-&amp;gt;x + rhs.x, this-&amp;gt;y + rhs.y, this-&amp;gt;z + rhs.z);
    }
    constexpr auto max() const{
        return std::max(std::max(this-&amp;gt;x,this-&amp;gt;y), this-&amp;gt;z);
    }
};
using Vector3f = Vector3&amp;lt;float&amp;gt;;
using Vector3d = Vector3&amp;lt;double&amp;gt;;
using Vector3i = Vector3&amp;lt;int&amp;gt;;
using Vector3l = Vector3&amp;lt;long&amp;gt;;

int main(){
    constexpr Vector3i v(10,20,30);

    constexpr Vector3i v1(20,30,40);
    constexpr auto v3 = v + v1;

    const std::array&amp;lt;int, v3.max()&amp;gt; arr = {};// array size = 70
    std::cout&amp;lt;&amp;lt;arr.size()&amp;lt;&amp;lt;std::endl;  //Will print out 70

    return EXIT_SUCCESS;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Generating &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; Vector3i class instances, calculating the sum of 2 vectors and pass the max value in array initialization as the array size. At function operator+ we can see 3 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; keywords, first one indicate &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; return value from a function, the second one - mean we send constant object inside the function and last one - mean this function do not change the internal state of the class. Also you can &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; functions as regular functions, like &lt;code class=&quot;highlighter-rouge&quot;&gt;auto vec = Vector3i(0,0,0);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; can be applied to variables, and functions. When you apply &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; to the variable you indicate - this variable will be assigned by a constant expression. In another hand when we apply &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; to function - we indicate this function &lt;strong&gt;can be&lt;/strong&gt; used as a constant expression.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;But what about &lt;strong&gt;metaprograming&lt;/strong&gt;?
In a few words &lt;a href=&quot;https://en.wikipedia.org/wiki/Metaprogramming&quot;&gt;metaprograming&lt;/a&gt; - is a programming technique in which program manipulate programs, the program can read, edit, generate, analyze another program. Also, I like this definition &lt;strong&gt;“write code then writes code”&lt;/strong&gt;.  If you familiar with Java, C# or any other language which have Reflection, reflection is a form metaprogramming. Also, you can write some program which generates source code, and after that, you compile this code - and you have a working program which was be created by another program.&lt;/p&gt;

&lt;p&gt;Aas we can see &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; values, will be calculated at compilation time, as the case we can implement some algorithm which does no depends on input data, and evaluate them inside our program for &lt;strong&gt;zero&lt;/strong&gt; time, by zero I mean constant O(1) complexity. Let’s try to implement something, simple like Fibonacci number. 
Actually, a Fibonacci number has &lt;a href=&quot;https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression&quot;&gt;Closed-form expression&lt;/a&gt; but we do not will use it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto fibonaciClosedForm(int n){
 	 //When we will invocate this func
 	 //we will compute only return statement
 	 //gratio,b and sqrt_5 will be computed in compilation time.
    constexpr auto sqrt_5 = 2.2360679775;
    constexpr auto gratio = (1 + sqrt_5)/2;
    constexpr auto b = (1 - sqrt_5) / 2;
    return (pow(gratio,n) - pow(b,n) ) / sqrt_5;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The sequence &lt;code class=&quot;highlighter-rouge&quot;&gt;F(n)&lt;/code&gt; of fibonacci number is defined by recurrence relation:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;F(n) = F(n-1) + F(n-2);
F(1) = 1;
F(2) = 1;
F(3) = F(2) + F(1); 
F(4) = F(3) + F(2); 
F(n) = F(n-1) + F(n-2)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The first thing that catches your eye is this expression has really bad complexity if we decide to use this equation without any optimization like memoization. In current expression, we compute the same functions multiple times, but we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt; and do not compute a function with the same input arguments twice.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//F(1) = 1
//F(2) = 1
//F(3) = F(2) + F(1)
//F(4) = F(3) + F(2)
//We will compute F(2) twice.
	
constexpr long long fibonaci_noconst(int n){
	if(n &amp;lt;= 1){
			return 1;
	}

	return fibonaci_noconst(n - 1) + fibonaci_noconst(n - 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But if we will use caching this problem will be gone, we store cache in a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::map&amp;lt;int, long  long&amp;gt;&lt;/code&gt;, where  key is function argument and value is function return value (actually we need to store only 2 previous function invocation results but in current case we store all results).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;map&amp;gt;
long long _fibonaci_rec(int n, std::map&amp;lt;int, long long&amp;gt;&amp;amp; cache){
    auto cached_value = cache.find(n);
    if(cached_value != cache.end()){
        return cached_value-&amp;gt;second;//Return cached value
    }

    auto v1 = _fibonaci_rec(n - 1, cache);
    auto v2 = _fibonaci_rec(n - 2, cache);

    cache[n] = v1 + v2; //store in cache
    return v1 + v2;
}

long long fibonaci_rec(int n){
    std::map&amp;lt;int, long long&amp;gt; cache = {
            {1 , 1}, //F(1) = 1
            {2 , 1}  //F(2) = 1
    };
    return _fibonaci_rec(n, cache);
}
int main(){
    cout&amp;lt;&amp;lt;fibonaci_rec(5); // 8
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; current realization can be easily converted into 1 for-loop, but in the current case, we use this approach, which simplifies understanding of memoization.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt;  fibonacci number calculation&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constexpr long long fibonaci(int n){
    if(n &amp;lt;= 1){
        return 1;
    }

    return fibonaci(n - 1) + fibonaci(n - 2);
}
...
constexpr auto res = fibonaci(5); //res = 8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;This code will be compiled with no problem, and the result of evaluation will be evaluated with zero time. But what about calculation Fibonacci number, where &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is a big number like 40? Actually 40 is not a big number, but result of Fibonaci function with n = 40 will be 165580141.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constexpr auto res = fibonaci(40); //Do not compiled
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I do not really know, maybe this code will be compiled by your compiler, but I have reasonable problems why this code does not compile, let’s look what compiler says:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1  error: constexpr variable 'res1' must be initialized by a constant expression
      constexpr ll res1 = fibonaci(40);
                   ^      ~~~~~~~~~~~~
2  note: constexpr evaluation hit maximum step limit; possible infinite loop?
    return fibonaci(n - 1) + fibonaci(n - 2);
3  note: in call to 'fibonaci(3)'
4  note: in call to 'fibonaci(4)'
5  note: in call to 'fibonaci(5)'
...
6  note: in call to 'fibonaci(40)'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At second line our compiler, says that we hit maximum step limit, it seems our compiler do not cache result of evaluation previous function :( 
Actually, we can compute the complexity of Fibonacci number without caching:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;T(n) - complexity for calculation Fibonacci for num = n
T(1) = 1
T(2) = 1
T(n) = T(n - 1) + T(n - 2) + O(1)  ; O(1) is sum operation T(n-1) + T(n-2)

Θ(n) = F(n) ; Tight Bound
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Calculating Fibonacci number without any modification has O(2 ^ n) complexity, cause we have a tree with depth = n, and a total number of nodes is 2 ^ n, &lt;strong&gt;its upper bound&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;But what about our compilation issues? We need compile with flag &lt;code class=&quot;highlighter-rouge&quot;&gt;-fconstexpr-steps=NUM&lt;/code&gt;, where a num is a number of maximum steps limit. I use &lt;strong&gt;clang-802.0.41&lt;/strong&gt;, now we can test our Fibonacci complexity. Let’s compute Fibonacci numb for example for num = 10, and set flags  &lt;code class=&quot;highlighter-rouge&quot;&gt;-fconstexpr-steps&lt;/code&gt; between 2^n and some number lower than 2^n. If program compiled with 2^n and do not compile with a number lower than 2^n, our complexity will be valid.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-fconstexpr-steps=1024, n = 10 =&amp;gt;  success compilation
-fconstexpr-steps=600, n = 10 =&amp;gt;  fail compilation

-fconstexpr-steps=512, n = 9 =&amp;gt;  success compilation
-fconstexpr-steps=256, n = 9 =&amp;gt;  fail compilation

-fconstexpr-steps=512, n = 9 =&amp;gt;  success compilation
-fconstexpr-steps=256, n = 9 =&amp;gt;  fail compilation

-fconstexpr-steps=32768, n = 15 =&amp;gt;  success compilation
-fconstexpr-steps=6500, n = 15 =&amp;gt;  fail compilation
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Yes, my clang compiler does not memoize &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; function invocation! 
But &lt;code class=&quot;highlighter-rouge&quot;&gt;constexpr&lt;/code&gt; is not only one way to calculate values in precompiled time, we can use c++ template way.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;long long N&amp;gt;
struct Fibonaci{
    enum{value = (Fibonaci&amp;lt;N-1&amp;gt;::value + Fibonaci&amp;lt;N-2&amp;gt;::value)};
};
template &amp;lt;&amp;gt;
struct Fibonaci&amp;lt;0&amp;gt;{
    enum {value = 1};
};
template &amp;lt;&amp;gt;
struct Fibonaci&amp;lt;1&amp;gt;{
    enum {value = 1};
};
template &amp;lt;&amp;gt;
struct Fibonaci&amp;lt;2&amp;gt;{
    enum {value = 1};
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This way will be compiled more faster, but by default recursive template instantiation maximum depth = 1024, if you want increase maximum depth add flag &lt;code class=&quot;highlighter-rouge&quot;&gt;-ftemplate-depth=N&lt;/code&gt;. In our case it’s not nessasery, cause calculation Fibonacci number for N&amp;gt;=1024 is really hard task.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Calculation time&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;chrono&amp;gt;
using namespace std;
using ll = long long;

constexpr long long fibonaci(ll n){
    if(n &amp;lt;= 1){
        return 1;
    }

    return fibonaci(n - 1) + fibonaci(n - 2);
}
constexpr ll fibonaci_noconst(ll n){
    if(n &amp;lt;= 2){
        return 1;
    }

    return fibonaci_noconst(n - 1) + fibonaci_noconst(n - 2);
}


template &amp;lt;ll N&amp;gt;
struct Fibonaci{
    enum{value = (Fibonaci&amp;lt;N-1&amp;gt;::value + Fibonaci&amp;lt;N-2&amp;gt;::value)};
};
template &amp;lt;&amp;gt;
struct Fibonaci&amp;lt;0&amp;gt;{
    enum {value = 1};
};
template &amp;lt;&amp;gt;
struct Fibonaci&amp;lt;1&amp;gt;{
    enum {value = 1};
};
template &amp;lt;&amp;gt;
struct Fibonaci&amp;lt;2&amp;gt;{
    enum {value = 1};
};


using namespace std;
#include &amp;lt;map&amp;gt;
long long _fibonaci_rec(int n, std::map&amp;lt;int, long long&amp;gt;&amp;amp; cache){
    auto cached_value = cache.find(n);
    if(cached_value != cache.end()){
        return cached_value-&amp;gt;second;//Return cached value
    }

    auto v1 = _fibonaci_rec(n - 1, cache);
    auto v2 = _fibonaci_rec(n - 2, cache);

    cache[n] = v1 + v2; //store in cache
    return v1 + v2;
}

long long fibonaci_rec(int n){
    std::map&amp;lt;int, long long&amp;gt; cache = {
            {1 , 1}, //F(0) = 1
            {2 , 1}  //F(1) = 1
    };
    return _fibonaci_rec(n, cache);
}

auto start = std::chrono::system_clock::now();
void startMeasurment(){
    start = std::chrono::system_clock::now();
}
void endMeasurmentTimeAndPrint(std::string method, int n){
    auto end = std::chrono::system_clock::now();
    auto elapsed =
            std::chrono::duration_cast&amp;lt;std::chrono::milliseconds&amp;gt;(end - start);
    std::cout&amp;lt;&amp;lt; method&amp;lt;&amp;lt;&quot; for num = &quot;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&quot;, total computation time: &quot;&amp;lt;&amp;lt; elapsed.count() &amp;lt;&amp;lt;&quot;ms&quot;&amp;lt;&amp;lt;endl;
}
int main(){
    constexpr ll num = 40;

    startMeasurment();
    constexpr auto f = fibonaci(num);
    endMeasurmentTimeAndPrint(&quot;Constexpr Fibonacci&quot;,num);

    startMeasurment();
    auto f1 = fibonaci_noconst(num);
    endMeasurmentTimeAndPrint(&quot;General Fibonacci&quot;,num);

    startMeasurment();
    auto f2 = Fibonaci&amp;lt;num&amp;gt;::value;
    endMeasurmentTimeAndPrint(&quot;Template Fibonacci&quot;,num);

    startMeasurment();
    auto f3 = fibonaci_rec(num);
    endMeasurmentTimeAndPrint(&quot;General Fibonacci with map cache&quot;,num);
}
//Compile with flag -fconstexpr-steps=1099162776
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Measure time computation for defferent type of calculation fibonaci num&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;On my MacBookPro 15 with 2.5 GHz Intel Core i7, it tooks 15minute for &lt;strong&gt;COMPILATION&lt;/strong&gt;. You can see results of evaluation bellow.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Constexpr Fibonacci for num = 40, total computation time: 0ms
General Fibonacci for num = 40, total computation time: 1580ms
Template Fibonacci for num = 40, total computation time: 0ms
General Fibonacci with map cache for num = 40, total computation time: 0ms

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">One guy said ‘if there were award for the most confusing word in C++11, constexpr would probably win it.’, and he was be correct. So what the difference between constexpr and regular const? constexpr can be used in 2 cases - apply constexpr to object and apply constexpr to function. Let’s look both cases:</summary></entry></feed>